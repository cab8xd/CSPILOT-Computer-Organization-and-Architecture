{\rtf1\ansi\ansicpg1252\cocoartf1671\cocoasubrtf100
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fnil\fcharset0 Menlo-Regular;\f2\fnil\fcharset0 Menlo-Bold;
\f3\fnil\fcharset0 Menlo-Italic;}
{\colortbl;\red255\green255\blue255;\red31\green31\blue36;\red253\green143\blue63;\red252\green106\blue93;
\red108\green121\blue134;\red252\green95\blue163;\red255\green255\blue255;\red150\green134\blue245;}
{\*\expandedcolortbl;;\csgenericrgb\c12054\c12284\c14131;\csgenericrgb\c99131\c56076\c24611;\csgenericrgb\c98912\c41558\c36568;
\csgenericrgb\c42394\c47462\c52518;\csgenericrgb\c98839\c37355\c63833;\csgenericrgb\c100000\c100000\c100000;\csgenericrgb\c58752\c52717\c95948;}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0

\f0\fs24 \cf0 \cb2 \
\pard\tx494\pardeftab494\pardirnatural\partightenfactor0

\f1\fs20 \cf3 #include \cf4 <stdio.h>
\f0\fs24 \cf0 \

\f1\fs20 \cf3 #include \cf4 <unistd.h>
\f0\fs24 \cf0 \

\f1\fs20 \cf3 #include \cf4 <string.h>
\f0\fs24 \cf0 \

\f1\fs20 \cf3 #include \cf4 <stdlib.h>
\f0\fs24 \cf0 \

\f1\fs20 \cf3 #include \cf4 <ctype.h>
\f0\fs24 \cf0 \

\f1\fs20 \cf3 #include \cf4 <stdio.h>
\f0\fs24 \cf0 \

\f1\fs20 \cf3 #include \cf4 <limits.h>
\f0\fs24 \cf0 \
\
\
\

\f1\fs20 \cf3 #ifndef __LINKEDLIST_H
\f0\fs24 \cf0 \

\f1\fs20 \cf3 #define __LINKEDLIST_H
\f0\fs24 \cf0 \
\

\f1\fs20 \cf5 /**
\f0\fs24 \cf0 \

\f1\fs20 \cf5  * A doubly linked-list node.
\f0\fs24 \cf0 \

\f1\fs20 \cf5  */
\f0\fs24 \cf0 \

\f2\b\fs20 \cf6 typedef
\f1\b0 \cf7  
\f2\b \cf6 struct
\f1\b0 \cf7  ll_node_s \{
\f0\fs24 \cf0 \

\f1\fs20 \cf7     
\f2\b \cf6 int
\f1\b0 \cf7  value;
\f0\fs24 \cf0 \

\f1\fs20 \cf7     
\f2\b \cf6 struct
\f1\b0 \cf7  ll_node_s *prev;
\f0\fs24 \cf0 \

\f1\fs20 \cf7     
\f2\b \cf6 struct
\f1\b0 \cf7  ll_node_s *next;
\f0\fs24 \cf0 \

\f1\fs20 \cf7 \} ll_node;
\f0\fs24 \cf0 \
\
\

\f1\fs20 \cf5 /**
\f0\fs24 \cf0 \

\f1\fs20 \cf5  * Returns a pointer to the first node of a list, given a pointer to any node
\f0\fs24 \cf0 \

\f1\fs20 \cf5  * in the list. If the provided pointer is `NULL`, instead returns `NULL`.
\f0\fs24 \cf0 \

\f1\fs20 \cf5  */
\f0\fs24 \cf0 \

\f1\fs20 \cf7 ll_node *ll_head(ll_node *list);
\f0\fs24 \cf0 \
\

\f1\fs20 \cf5 /**
\f0\fs24 \cf0 \

\f1\fs20 \cf5  * Returns a pointer to the last node of a list, given a pointer to any node
\f0\fs24 \cf0 \

\f1\fs20 \cf5  * in the list. If the provided pointer is `NULL`, instead returns `NULL`.
\f0\fs24 \cf0 \

\f1\fs20 \cf5  */
\f0\fs24 \cf0 \

\f1\fs20 \cf7 ll_node *ll_tail(ll_node *list);
\f0\fs24 \cf0 \
\

\f1\fs20 \cf5 /**
\f0\fs24 \cf0 \

\f1\fs20 \cf5  * Returns the number of nodes in the list, which is the same for all nodes
\f0\fs24 \cf0 \

\f1\fs20 \cf5  * in the list and 0 for `NULL`.
\f0\fs24 \cf0 \

\f1\fs20 \cf5  */
\f0\fs24 \cf0 \

\f2\b\fs20 \cf6 unsigned
\f1\b0 \cf7  
\f2\b \cf6 long
\f1\b0 \cf7  ll_length(ll_node *list);
\f0\fs24 \cf0 \
\

\f1\fs20 \cf5 /**
\f0\fs24 \cf0 \

\f1\fs20 \cf5  * Given a pointer to a node in a list, returns a pointer to the first node
\f0\fs24 \cf0 \

\f1\fs20 \cf5  * at or after that node which has the given `value`. If given `NULL`, or
\f0\fs24 \cf0 \

\f1\fs20 \cf5  * if no such node exists, returns `NULL`.
\f0\fs24 \cf0 \

\f1\fs20 \cf5  */
\f0\fs24 \cf0 \

\f1\fs20 \cf7 ll_node *ll_find(ll_node *list, 
\f2\b \cf6 int
\f1\b0 \cf7  value);
\f0\fs24 \cf0 \
\
\

\f1\fs20 \cf5 /**
\f0\fs24 \cf0 \

\f1\fs20 \cf5  * Given a pointer to a node in a list, remove that node from the list,
\f0\fs24 \cf0 \

\f1\fs20 \cf5  * `free`ing its memory in the process. Returns a pointer to the node that now
\f0\fs24 \cf0 \

\f1\fs20 \cf5  * occupies the same position in the list that the removed node used to occupy
\f0\fs24 \cf0 \

\f1\fs20 \cf5  * (which may be `NULL` if the removed node was the last node in the list).
\f0\fs24 \cf0 \

\f1\fs20 \cf5  *
\f0\fs24 \cf0 \

\f1\fs20 \cf5  * If given `NULL`, this function does nothing and returns `NULL`.
\f0\fs24 \cf0 \

\f1\fs20 \cf5  */
\f0\fs24 \cf0 \

\f1\fs20 \cf7 ll_node *ll_remove(ll_node *list);
\f0\fs24 \cf0 \
\

\f1\fs20 \cf5 /**
\f0\fs24 \cf0 \

\f1\fs20 \cf5  * Extend a list by one by adding `value` next to `list`. If `before` is 0,
\f0\fs24 \cf0 \

\f1\fs20 \cf5  * inserts `value` immediately following the node pointed to by `list`;
\f0\fs24 \cf0 \

\f1\fs20 \cf5  * otherwise inserts `value` immediately before that node. If `list` is NULL,
\f0\fs24 \cf0 \

\f1\fs20 \cf5  * the newly inserted node is the entire list. In all cases, the new node is
\f0\fs24 \cf0 \

\f1\fs20 \cf5  * allocated using `malloc` and returned by the function.
\f0\fs24 \cf0 \

\f1\fs20 \cf5  */
\f0\fs24 \cf0 \

\f1\fs20 \cf7 ll_node *ll_insert(
\f2\b \cf6 int
\f1\b0 \cf7  value, ll_node *list, 
\f2\b \cf6 int
\f1\b0 \cf7  before);
\f0\fs24 \cf0 \
\

\f1\fs20 \cf5 /**
\f0\fs24 \cf0 \

\f1\fs20 \cf5  * Displays the contents of the list separated by commas and surrounded by
\f0\fs24 \cf0 \

\f1\fs20 \cf5  * brackets, with the pointed-to node highlighted with asterisks.
\f0\fs24 \cf0 \

\f1\fs20 \cf5  */
\f0\fs24 \cf0 \

\f2\b\fs20 \cf6 void
\f1\b0 \cf7  ll_show(ll_node *list);
\f0\fs24 \cf0 \
\
\

\f1\fs20 \cf3 #endif 
\f3\i \cf5 /* ifdef __LINKEDLIST_H */
\f0\i0\fs24 \cf0 \
\

\f1\fs20 \cf7 ll_node *ll_head(ll_node *list)\{
\f0\fs24 \cf0 \

\f1\fs20 \cf7     
\f2\b \cf6 if
\f1\b0 \cf7 (list == 
\f2\b \cf6 NULL
\f1\b0 \cf7 )
\f0\fs24 \cf0 \

\f1\fs20 \cf7         
\f2\b \cf6 return
\f1\b0 \cf7  
\f2\b \cf6 NULL
\f1\b0 \cf7 ;
\f0\fs24 \cf0 \

\f1\fs20 \cf7     
\f2\b \cf6 while
\f1\b0 \cf7 (list->prev != 
\f2\b \cf6 NULL
\f1\b0 \cf7 )
\f0\fs24 \cf0 \

\f1\fs20 \cf7         list = list->prev;
\f0\fs24 \cf0 \

\f1\fs20 \cf7     
\f2\b \cf6 return
\f1\b0 \cf7  list; 
\f3\i \cf5 //returns the head node.
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7 \}
\f0\fs24 \cf0 \
\

\f1\fs20 \cf7 ll_node *ll_tail(ll_node *list)\{
\f0\fs24 \cf0 \

\f1\fs20 \cf7     
\f2\b \cf6 if
\f1\b0 \cf7 (list == 
\f2\b \cf6 NULL
\f1\b0 \cf7 )
\f0\fs24 \cf0 \

\f1\fs20 \cf7         
\f2\b \cf6 return
\f1\b0 \cf7  
\f2\b \cf6 NULL
\f1\b0 \cf7 ;
\f0\fs24 \cf0 \

\f1\fs20 \cf7     
\f2\b \cf6 while
\f1\b0 \cf7 (list->next != 
\f2\b \cf6 NULL
\f1\b0 \cf7 )
\f0\fs24 \cf0 \

\f1\fs20 \cf7         list = list->next;
\f0\fs24 \cf0 \

\f1\fs20 \cf7     
\f2\b \cf6 return
\f1\b0 \cf7  list; 
\f3\i \cf5 //returns the tail node.
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7     
\f0\fs24 \cf0 \

\f1\fs20 \cf7 \}
\f0\fs24 \cf0 \

\f2\b\fs20 \cf6 void
\f1\b0 \cf7  ll_show(ll_node *list) \{
\f0\fs24 \cf0 \

\f1\fs20 \cf7     ll_node *ptr = ll_head(list);
\f0\fs24 \cf0 \

\f1\fs20 \cf7     printf(\cf4 "%c"\cf7 , \cf8 '['\cf7 );
\f0\fs24 \cf0 \

\f1\fs20 \cf7     
\f2\b \cf6 while
\f1\b0 \cf7 (ptr) \{
\f0\fs24 \cf0 \

\f1\fs20 \cf7         
\f2\b \cf6 if
\f1\b0 \cf7  (ptr->prev) printf(\cf4 "%c"\cf7 , \cf8 ','\cf7 );
\f0\fs24 \cf0 \

\f1\fs20 \cf7         
\f3\i \cf5 // if (ptr == list) putchar('*');
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7         printf(\cf4 " %d"\cf7 , ptr->value);
\f0\fs24 \cf0 \

\f1\fs20 \cf7         
\f3\i \cf5 //  if (ptr == list) putchar('*');
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7         ptr = ptr->next;
\f0\fs24 \cf0 \

\f1\fs20 \cf7     \}
\f0\fs24 \cf0 \

\f1\fs20 \cf7     puts(\cf4 " ]"\cf7 );
\f0\fs24 \cf0 \

\f1\fs20 \cf7 \}
\f0\fs24 \cf0 \
\
\
\

\f1\fs20 \cf7 ll_node *ll_remove(ll_node *list)
\f0\fs24 \cf0 \

\f1\fs20 \cf7 \{
\f0\fs24 \cf0 \

\f1\fs20 \cf7     ll_node *curN;
\f0\fs24 \cf0 \

\f1\fs20 \cf7     
\f0\fs24 \cf0 \

\f1\fs20 \cf7     
\f2\b \cf6 if
\f1\b0 \cf7 (list == 
\f2\b \cf6 NULL
\f1\b0 \cf7 )
\f0\fs24 \cf0 \

\f1\fs20 \cf7         
\f2\b \cf6 return
\f1\b0 \cf7  
\f2\b \cf6 NULL
\f1\b0 \cf7 ;
\f0\fs24 \cf0 \

\f1\fs20 \cf7     
\f0\fs24 \cf0 \

\f1\fs20 \cf7     
\f3\i \cf5 //removes the node
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7     
\f0\fs24 \cf0 \

\f1\fs20 \cf7     
\f3\i \cf5 //Singleton
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7     
\f0\fs24 \cf0 \

\f1\fs20 \cf7     
\f2\b \cf6 if
\f1\b0 \cf7 (list->next == 
\f2\b \cf6 NULL
\f1\b0 \cf7  && list->prev == 
\f2\b \cf6 NULL
\f1\b0 \cf7 )
\f0\fs24 \cf0 \

\f1\fs20 \cf7     \{
\f0\fs24 \cf0 \

\f1\fs20 \cf7         curN = 
\f2\b \cf6 NULL
\f1\b0 \cf7 ;
\f0\fs24 \cf0 \

\f1\fs20 \cf7         
\f0\fs24 \cf0 \

\f1\fs20 \cf7     \}
\f0\fs24 \cf0 \

\f1\fs20 \cf7     
\f0\fs24 \cf0 \

\f1\fs20 \cf7     
\f2\b \cf6 else
\f1\b0 \cf7   
\f2\b \cf6 if
\f1\b0 \cf7 (list->next == 
\f2\b \cf6 NULL
\f1\b0 \cf7 )\{ 
\f3\i \cf5 //tail case
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7         curN = list->prev;
\f0\fs24 \cf0 \

\f1\fs20 \cf7         list->prev->next = 
\f2\b \cf6 NULL
\f1\b0 \cf7 ;
\f0\fs24 \cf0 \

\f1\fs20 \cf7         curN = 
\f2\b \cf6 NULL
\f1\b0 \cf7 ;
\f0\fs24 \cf0 \

\f1\fs20 \cf7     \}
\f0\fs24 \cf0 \

\f1\fs20 \cf7     
\f0\fs24 \cf0 \

\f1\fs20 \cf7     
\f2\b \cf6 else
\f1\b0 \cf7  
\f2\b \cf6 if
\f1\b0 \cf7 (list->prev == 
\f2\b \cf6 NULL
\f1\b0 \cf7 )
\f3\i \cf5 //head case
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7     \{
\f0\fs24 \cf0 \

\f1\fs20 \cf7         curN = list->next;
\f0\fs24 \cf0 \

\f1\fs20 \cf7         list->next->prev = list->prev;
\f0\fs24 \cf0 \

\f1\fs20 \cf7     \}
\f0\fs24 \cf0 \

\f1\fs20 \cf7     
\f0\fs24 \cf0 \

\f1\fs20 \cf7     
\f2\b \cf6 else
\f1\b0 \cf7  
\f3\i \cf5 //otherwise:
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7     \{
\f0\fs24 \cf0 \

\f1\fs20 \cf7         curN = list->next;
\f0\fs24 \cf0 \

\f1\fs20 \cf7         list->prev->next = list->next;
\f0\fs24 \cf0 \

\f1\fs20 \cf7         list->next->prev = list->prev;
\f0\fs24 \cf0 \

\f1\fs20 \cf7     \}
\f0\fs24 \cf0 \

\f1\fs20 \cf7     
\f0\fs24 \cf0 \

\f1\fs20 \cf7     free(list);
\f0\fs24 \cf0 \

\f1\fs20 \cf7     
\f3\i \cf5 //need anything here?
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7     
\f2\b \cf6 return
\f1\b0 \cf7  curN;
\f0\fs24 \cf0 \

\f1\fs20 \cf7     
\f0\fs24 \cf0 \

\f1\fs20 \cf7     
\f0\fs24 \cf0 \

\f1\fs20 \cf7 \}
\f0\fs24 \cf0 \

\f1\fs20 \cf7 ll_node *ll_pop(ll_node *list)
\f0\fs24 \cf0 \

\f1\fs20 \cf7 \{
\f0\fs24 \cf0 \

\f1\fs20 \cf7     
\f3\i \cf5 //puts("pop method");
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7     ll_node *curN;
\f0\fs24 \cf0 \

\f1\fs20 \cf7     
\f3\i \cf5 //puts("list before");
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7     
\f3\i \cf5 // ll_show(list);
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7     
\f0\fs24 \cf0 \

\f1\fs20 \cf7     
\f2\b \cf6 if
\f1\b0 \cf7 (list == 
\f2\b \cf6 NULL
\f1\b0 \cf7 )
\f0\fs24 \cf0 \

\f1\fs20 \cf7         
\f2\b \cf6 return
\f1\b0 \cf7  
\f2\b \cf6 NULL
\f1\b0 \cf7 ;
\f0\fs24 \cf0 \

\f1\fs20 \cf7     
\f2\b \cf6 if
\f1\b0 \cf7 (list->next == 
\f2\b \cf6 NULL
\f1\b0 \cf7  && list->prev == 
\f2\b \cf6 NULL
\f1\b0 \cf7 )
\f0\fs24 \cf0 \

\f1\fs20 \cf7     \{
\f0\fs24 \cf0 \

\f1\fs20 \cf7         
\f3\i \cf5 //puts("Singly Node");
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7         curN = 
\f2\b \cf6 NULL
\f1\b0 \cf7 ;
\f0\fs24 \cf0 \

\f1\fs20 \cf7         
\f0\fs24 \cf0 \

\f1\fs20 \cf7     \}
\f0\fs24 \cf0 \

\f1\fs20 \cf7     
\f2\b \cf6 else
\f1\b0 \cf7 \{
\f0\fs24 \cf0 \

\f1\fs20 \cf7         
\f2\b \cf6 while
\f1\b0 \cf7 (list->next != 
\f2\b \cf6 NULL
\f1\b0 \cf7 ) 
\f3\i \cf5 //Move to the head of the list.
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7             list = list->next;
\f0\fs24 \cf0 \

\f1\fs20 \cf7         
\f0\fs24 \cf0 \

\f1\fs20 \cf7         curN = list->prev;
\f0\fs24 \cf0 \

\f1\fs20 \cf7         list->prev->next = 
\f2\b \cf6 NULL
\f1\b0 \cf7 ; 
\f3\i \cf5 //Set the next node's prev to NULL
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7         
\f0\fs24 \cf0 \

\f1\fs20 \cf7         
\f0\fs24 \cf0 \

\f1\fs20 \cf7     \}
\f0\fs24 \cf0 \

\f1\fs20 \cf7     
\f3\i \cf5 // puts("list after");
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7     
\f3\i \cf5 // ll_show(list);
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7     free(list);
\f0\fs24 \cf0 \

\f1\fs20 \cf7     
\f3\i \cf5 // puts("list after free");
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7     
\f3\i \cf5 //  ll_show(list);
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7     
\f2\b \cf6 return
\f1\b0 \cf7  curN;
\f0\fs24 \cf0 \

\f1\fs20 \cf7 \}
\f0\fs24 \cf0 \
\

\f2\b\fs20 \cf6 int
\f1\b0 \cf7  ll_peek(ll_node *list)
\f0\fs24 \cf0 \

\f1\fs20 \cf7 \{
\f0\fs24 \cf0 \

\f1\fs20 \cf7     
\f3\i \cf5 //puts("Peeking.");
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7     
\f3\i \cf5 //ll_show(list);
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7     
\f3\i \cf5 // printf("%d\\n", list->value);
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7     
\f2\b \cf6 return
\f1\b0 \cf7  list->value;
\f0\fs24 \cf0 \

\f1\fs20 \cf7 \}
\f0\fs24 \cf0 \
\

\f1\fs20 \cf7 ll_node *ll_insert(
\f2\b \cf6 int
\f1\b0 \cf7  value, ll_node *list, 
\f2\b \cf6 int
\f1\b0 \cf7  before)
\f0\fs24 \cf0 \

\f1\fs20 \cf7 \{
\f0\fs24 \cf0 \

\f1\fs20 \cf7     
\f3\i \cf5 //the new node
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7     ll_node* new  = (ll_node*)malloc(
\f2\b \cf6 sizeof
\f1\b0 \cf7 (ll_node));
\f0\fs24 \cf0 \

\f1\fs20 \cf7     new->value = value;
\f0\fs24 \cf0 \

\f1\fs20 \cf7     new->next = 
\f2\b \cf6 NULL
\f1\b0 \cf7 ;
\f0\fs24 \cf0 \

\f1\fs20 \cf7     new->prev = 
\f2\b \cf6 NULL
\f1\b0 \cf7 ;
\f0\fs24 \cf0 \

\f1\fs20 \cf7     
\f0\fs24 \cf0 \

\f1\fs20 \cf7     
\f3\i \cf5 //    errors:     insert before/after head (crash)
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7     
\f3\i \cf5 //    insert after null - crash
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7     
\f2\b \cf6 if
\f1\b0 \cf7 (list == 
\f2\b \cf6 NULL
\f1\b0 \cf7 )
\f0\fs24 \cf0 \

\f1\fs20 \cf7         
\f2\b \cf6 return
\f1\b0 \cf7  new;
\f0\fs24 \cf0 \

\f1\fs20 \cf7     
\f0\fs24 \cf0 \

\f1\fs20 \cf7     
\f0\fs24 \cf0 \

\f1\fs20 \cf7     
\f0\fs24 \cf0 \

\f1\fs20 \cf7     
\f3\i \cf5 //if before is zero, insert the value AFTER list node
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7     
\f2\b \cf6 else
\f1\b0 \cf7  
\f2\b \cf6 if
\f1\b0 \cf7 (before < \cf8 1\cf7 )
\f0\fs24 \cf0 \

\f1\fs20 \cf7     \{
\f0\fs24 \cf0 \

\f1\fs20 \cf7         
\f3\i \cf5 /*    //Insert after null
\f0\i0\fs24 \cf0 \

\f3\i\fs20 \cf5          if(list->next == NULL  && list->prev == NULL)
\f0\i0\fs24 \cf0 \

\f3\i\fs20 \cf5          \{
\f0\i0\fs24 \cf0 \

\f3\i\fs20 \cf5          list->next = new;
\f0\i0\fs24 \cf0 \

\f3\i\fs20 \cf5          \}
\f0\i0\fs24 \cf0 \

\f3\i\fs20 \cf5          
\f0\i0\fs24 \cf0 \

\f3\i\fs20 \cf5          */
\f1\i0 \cf7     
\f3\i \cf5 //Tail case
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7         
\f3\i \cf5 //need if statements head or tail for both insert cases
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7         
\f2\b \cf6 if
\f1\b0 \cf7  (list->next == 
\f2\b \cf6 NULL
\f1\b0 \cf7 ) 
\f3\i \cf5 //if the element is the tail
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7         \{
\f0\fs24 \cf0 \

\f1\fs20 \cf7             new->prev = list;
\f0\fs24 \cf0 \

\f1\fs20 \cf7             list->next = new;
\f0\fs24 \cf0 \

\f1\fs20 \cf7             new->next = 
\f2\b \cf6 NULL
\f1\b0 \cf7 ;
\f0\fs24 \cf0 \

\f1\fs20 \cf7             
\f0\fs24 \cf0 \

\f1\fs20 \cf7         \}
\f0\fs24 \cf0 \

\f1\fs20 \cf7         
\f3\i \cf5 //Head case
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7         
\f2\b \cf6 else
\f1\b0 \cf7  
\f2\b \cf6 if
\f1\b0 \cf7 (list->prev == 
\f2\b \cf6 NULL
\f1\b0 \cf7 )
\f3\i \cf5 //if the element is the head
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7         \{
\f0\fs24 \cf0 \

\f1\fs20 \cf7             
\f3\i \cf5 //Error: wrong prev?
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7             
\f0\fs24 \cf0 \

\f1\fs20 \cf7             new->prev = list;
\f0\fs24 \cf0 \

\f1\fs20 \cf7             new->next = list->next;
\f3\i \cf5 //list pointer exists (next)
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7             list->next->prev = new;
\f0\fs24 \cf0 \

\f1\fs20 \cf7             list->next = new;
\f0\fs24 \cf0 \

\f1\fs20 \cf7         \}
\f0\fs24 \cf0 \

\f1\fs20 \cf7         
\f0\fs24 \cf0 \

\f1\fs20 \cf7         
\f0\fs24 \cf0 \

\f1\fs20 \cf7         
\f3\i \cf5 //Otherwise...
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7         
\f2\b \cf6 else
\f0\b0\fs24 \cf0 \

\f1\fs20 \cf7         \{
\f0\fs24 \cf0 \

\f1\fs20 \cf7             new->prev = list;
\f0\fs24 \cf0 \

\f1\fs20 \cf7             new->next = list->next;
\f3\i \cf5 //list pointer exists (next)
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7             list->next->prev = new; 
\f3\i \cf5 //list->next pointer doesn't exist
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7             list->next = new;
\f0\fs24 \cf0 \

\f1\fs20 \cf7         \}
\f0\fs24 \cf0 \

\f1\fs20 \cf7     \}
\f0\fs24 \cf0 \

\f1\fs20 \cf7     
\f0\fs24 \cf0 \

\f1\fs20 \cf7     
\f3\i \cf5 //need if statements head or tail for both insert cases
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7     
\f2\b \cf6 else
\f1\b0 \cf7  
\f2\b \cf6 if
\f1\b0 \cf7 (list->next == 
\f2\b \cf6 NULL
\f1\b0 \cf7 )
\f0\fs24 \cf0 \

\f1\fs20 \cf7     \{
\f0\fs24 \cf0 \

\f1\fs20 \cf7         new->next = list;
\f0\fs24 \cf0 \

\f1\fs20 \cf7         new->prev = list->prev;
\f0\fs24 \cf0 \

\f1\fs20 \cf7         
\f0\fs24 \cf0 \

\f1\fs20 \cf7         list->prev = new;
\f0\fs24 \cf0 \

\f1\fs20 \cf7         list->prev->prev->next = new;
\f0\fs24 \cf0 \

\f1\fs20 \cf7     \}
\f0\fs24 \cf0 \

\f1\fs20 \cf7     
\f2\b \cf6 else
\f1\b0 \cf7  
\f2\b \cf6 if
\f1\b0 \cf7 (list->prev == 
\f2\b \cf6 NULL
\f1\b0 \cf7 )
\f0\fs24 \cf0 \

\f1\fs20 \cf7     \{
\f0\fs24 \cf0 \

\f1\fs20 \cf7         new->next = list;
\f0\fs24 \cf0 \

\f1\fs20 \cf7         
\f0\fs24 \cf0 \

\f1\fs20 \cf7         list->prev = new;
\f0\fs24 \cf0 \

\f1\fs20 \cf7     \}
\f0\fs24 \cf0 \

\f1\fs20 \cf7     
\f0\fs24 \cf0 \

\f1\fs20 \cf7     
\f0\fs24 \cf0 \

\f1\fs20 \cf7     
\f2\b \cf6 else
\f0\b0\fs24 \cf0 \

\f1\fs20 \cf7     \{
\f0\fs24 \cf0 \

\f1\fs20 \cf7         
\f0\fs24 \cf0 \

\f1\fs20 \cf7         
\f0\fs24 \cf0 \

\f1\fs20 \cf7         
\f0\fs24 \cf0 \

\f1\fs20 \cf7         
\f3\i \cf5 //insert value BEFORE node
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7         new->next = list;
\f0\fs24 \cf0 \

\f1\fs20 \cf7         new->prev = list->prev;
\f0\fs24 \cf0 \

\f1\fs20 \cf7         
\f0\fs24 \cf0 \

\f1\fs20 \cf7         list->prev->next = new;
\f0\fs24 \cf0 \

\f1\fs20 \cf7         list->prev = new;
\f0\fs24 \cf0 \

\f1\fs20 \cf7     \}
\f0\fs24 \cf0 \

\f1\fs20 \cf7     
\f0\fs24 \cf0 \

\f1\fs20 \cf7     
\f2\b \cf6 return
\f1\b0 \cf7  new ;
\f0\fs24 \cf0 \

\f1\fs20 \cf7 \}
\f0\fs24 \cf0 \
\
\
\

\f1\fs20 \cf7 ll_node *ll_push(
\f2\b \cf6 int
\f1\b0 \cf7  value, ll_node *list)\{
\f0\fs24 \cf0 \

\f1\fs20 \cf7     
\f0\fs24 \cf0 \

\f1\fs20 \cf7     
\f2\b \cf6 return
\f1\b0 \cf7  ll_insert(value, list, \cf8 0\cf7 );
\f0\fs24 \cf0 \

\f1\fs20 \cf7 \}
\f0\fs24 \cf0 \
\
\
\

\f2\b\fs20 \cf6 int
\f1\b0 \cf7  main(
\f2\b \cf6 int
\f1\b0 \cf7  argc, 
\f2\b \cf6 char
\f1\b0 \cf7  
\f2\b \cf6 const
\f1\b0 \cf7  *argv[])\{
\f0\fs24 \cf0 \

\f1\fs20 \cf7     
\f0\fs24 \cf0 \

\f1\fs20 \cf7     
\f2\b \cf6 char
\f1\b0 \cf7  buff[\cf8 4096\cf7 ];
\f0\fs24 \cf0 \

\f1\fs20 \cf7     size_t size = \cf8 4096\cf7 ;
\f0\fs24 \cf0 \

\f1\fs20 \cf7     
\f2\b \cf6 int
\f1\b0 \cf7  i;
\f0\fs24 \cf0 \

\f1\fs20 \cf7     ll_node *stack;
\f0\fs24 \cf0 \

\f1\fs20 \cf7     ll_node *temp;
\f0\fs24 \cf0 \

\f1\fs20 \cf7     
\f2\b \cf6 int
\f1\b0 \cf7  count = \cf8 0\cf7 ;
\f0\fs24 \cf0 \

\f1\fs20 \cf7     
\f0\fs24 \cf0 \

\f1\fs20 \cf7     
\f2\b \cf6 while
\f1\b0 \cf7 (\cf8 1\cf7 ) 
\f3\i \cf5 //EOF check
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7     \{
\f0\fs24 \cf0 \

\f1\fs20 \cf7         
\f2\b \cf6 if
\f1\b0 \cf7 (read(\cf8 0\cf7 , buff, size) == \cf8 0\cf7 )
\f0\fs24 \cf0 \

\f1\fs20 \cf7         \{
\f0\fs24 \cf0 \

\f1\fs20 \cf7             ll_show(stack);
\f0\fs24 \cf0 \

\f1\fs20 \cf7             
\f2\b \cf6 return
\f1\b0 \cf7  \cf8 0\cf7 ;
\f0\fs24 \cf0 \

\f1\fs20 \cf7         \}
\f0\fs24 \cf0 \

\f1\fs20 \cf7         
\f3\i \cf5 //  puts("Wow");
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7         
\f3\i \cf5 //  printf("Buffer is ");
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7         
\f3\i \cf5 //  puts(buff);
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7         
\f0\fs24 \cf0 \

\f1\fs20 \cf7         
\f2\b \cf6 char
\f1\b0 \cf7  *string = strdup(buff);
\f0\fs24 \cf0 \

\f1\fs20 \cf7         
\f2\b \cf6 char
\f1\b0 \cf7  *s;
\f0\fs24 \cf0 \

\f1\fs20 \cf7         
\f2\b \cf6 int
\f1\b0 \cf7  num;
\f0\fs24 \cf0 \

\f1\fs20 \cf7         
\f2\b \cf6 char
\f1\b0 \cf7  *t;
\f0\fs24 \cf0 \

\f1\fs20 \cf7         
\f0\fs24 \cf0 \

\f1\fs20 \cf7         
\f0\fs24 \cf0 \

\f1\fs20 \cf7         
\f0\fs24 \cf0 \

\f1\fs20 \cf7         
\f2\b \cf6 int
\f1\b0 \cf7  result;
\f0\fs24 \cf0 \

\f1\fs20 \cf7         
\f2\b \cf6 int
\f1\b0 \cf7  op1;
\f0\fs24 \cf0 \

\f1\fs20 \cf7         
\f2\b \cf6 int
\f1\b0 \cf7  op2;
\f0\fs24 \cf0 \

\f1\fs20 \cf7         
\f0\fs24 \cf0 \

\f1\fs20 \cf7         
\f0\fs24 \cf0 \

\f1\fs20 \cf7         
\f3\i \cf5 //Sort through the buffer.
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7         
\f2\b \cf6 while
\f1\b0 \cf7 (( s = strsep(&string,\cf4 " "\cf7 )) != 
\f2\b \cf6 NULL
\f1\b0 \cf7 )\{
\f0\fs24 \cf0 \

\f1\fs20 \cf7             
\f3\i \cf5 // ll_show(stack);
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7             
\f0\fs24 \cf0 \

\f1\fs20 \cf7             
\f0\fs24 \cf0 \

\f1\fs20 \cf7             
\f3\i \cf5 //puts("Stack is ");
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7             
\f3\i \cf5 //  ll_show(stack);
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7             
\f0\fs24 \cf0 \

\f1\fs20 \cf7             
\f3\i \cf5 //  printf("s is (%s) \\n", s);
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7             
\f2\b \cf6 if
\f1\b0 \cf7 (strcmp(s,\cf4 " "\cf7 ) != \cf8 0\cf7  && strcmp(s,\cf4 ""\cf7 ) != \cf8 0\cf7  )
\f0\fs24 \cf0 \

\f1\fs20 \cf7             \{
\f0\fs24 \cf0 \

\f1\fs20 \cf7                 
\f0\fs24 \cf0 \

\f1\fs20 \cf7                 
\f2\b \cf6 if
\f1\b0 \cf7 (((num = strtol(s,&t,\cf8 10\cf7 )) != \cf8 0\cf7 ) || strcmp(s,\cf4 "0"\cf7 ) == \cf8 0\cf7  || strcmp(s,\cf4 "0\\n"\cf7 )  == \cf8 0\cf7  || strcmp(s,\cf4 "0 "\cf7 ) == \cf8 0\cf7  || strcmp(s,\cf4 "0 \\n"\cf7 ) == \cf8 0\cf7  || strstr(s,\cf4 "0"\cf7 ) != 
\f2\b \cf6 NULL
\f1\b0 \cf7 )
\f0\fs24 \cf0 \

\f1\fs20 \cf7                 \{
\f0\fs24 \cf0 \

\f1\fs20 \cf7                     
\f3\i \cf5 //  printf("Adding %d to stack. \\n", num);
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7                     stack = ll_push(num,stack);
\f0\fs24 \cf0 \

\f1\fs20 \cf7                     count += \cf8 1\cf7 ;
\f0\fs24 \cf0 \

\f1\fs20 \cf7                     
\f0\fs24 \cf0 \

\f1\fs20 \cf7                     
\f0\fs24 \cf0 \

\f1\fs20 \cf7                 \}
\f0\fs24 \cf0 \

\f1\fs20 \cf7           
\f0\fs24 \cf0 \

\f1\fs20 \cf7                 
\f3\i \cf5 //Adding
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7                 
\f2\b \cf6 else
\f1\b0 \cf7  
\f2\b \cf6 if
\f1\b0 \cf7 (strcmp(s,\cf4 "+"\cf7 ) == \cf8 0\cf7  || strcmp(s,\cf4 "+\\n"\cf7 )  == \cf8 0\cf7  || strcmp(s,\cf4 "+ "\cf7 ) == \cf8 0\cf7  || strcmp(s,\cf4 "+ \\n"\cf7 ) == \cf8 0\cf7 )
\f0\fs24 \cf0 \

\f1\fs20 \cf7                 \{
\f0\fs24 \cf0 \

\f1\fs20 \cf7                     
\f2\b \cf6 if
\f1\b0 \cf7 (count < \cf8 2\cf7 )
\f0\fs24 \cf0 \

\f1\fs20 \cf7                     \{
\f0\fs24 \cf0 \

\f1\fs20 \cf7                         
\f3\i \cf5 //                ll_show(stack);
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7                         
\f2\b \cf6 return
\f1\b0 \cf7  \cf8 0\cf7 ;
\f0\fs24 \cf0 \

\f1\fs20 \cf7                     \}
\f0\fs24 \cf0 \

\f1\fs20 \cf7                     
\f0\fs24 \cf0 \

\f1\fs20 \cf7                     
\f3\i \cf5 //                puts("Adding");
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7                     op2 = ll_peek(stack);
\f0\fs24 \cf0 \

\f1\fs20 \cf7                     stack = ll_pop(stack);
\f0\fs24 \cf0 \

\f1\fs20 \cf7                     
\f3\i \cf5 //               ll_show(stack);
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7                     
\f3\i \cf5 //                printf("op2 = %d \\n", op2);
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7                     
\f0\fs24 \cf0 \

\f1\fs20 \cf7                     op1 = ll_peek(stack);
\f0\fs24 \cf0 \

\f1\fs20 \cf7                     
\f0\fs24 \cf0 \

\f1\fs20 \cf7                     stack = ll_pop(stack);
\f0\fs24 \cf0 \

\f1\fs20 \cf7                     
\f3\i \cf5 //                ll_show(stack);
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7                     
\f3\i \cf5 //               printf("op1 = %d \\n", op1);
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7                     
\f0\fs24 \cf0 \

\f1\fs20 \cf7                     result = op1 + op2;
\f0\fs24 \cf0 \

\f1\fs20 \cf7                     
\f0\fs24 \cf0 \

\f1\fs20 \cf7                     
\f3\i \cf5 //   printf("result = %d \\n", result);
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7                     
\f0\fs24 \cf0 \

\f1\fs20 \cf7                     stack =  ll_push(result,stack);
\f0\fs24 \cf0 \

\f1\fs20 \cf7                     
\f3\i \cf5 //               puts("push result onto stack");
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7                      
\f3\i \cf5 //            ll_show(stack);
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7                     count-= \cf8 1\cf7 ;
\f0\fs24 \cf0 \

\f1\fs20 \cf7                 \}
\f0\fs24 \cf0 \

\f1\fs20 \cf7                 
\f3\i \cf5 //Subtracting
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7                 
\f2\b \cf6 else
\f1\b0 \cf7  
\f2\b \cf6 if
\f1\b0 \cf7 (strcmp(s,\cf4 "-"\cf7 ) == \cf8 0\cf7  || strcmp(s,\cf4 "-\\n"\cf7 )  == \cf8 0\cf7  || strcmp(s,\cf4 "- "\cf7 ) == \cf8 0\cf7  || strcmp(s,\cf4 "- \\n"\cf7 ) == \cf8 0\cf7 )
\f0\fs24 \cf0 \

\f1\fs20 \cf7                 \{
\f0\fs24 \cf0 \

\f1\fs20 \cf7                     
\f2\b \cf6 if
\f1\b0 \cf7 (count < \cf8 2\cf7 )
\f0\fs24 \cf0 \

\f1\fs20 \cf7                     \{
\f0\fs24 \cf0 \

\f1\fs20 \cf7                         
\f3\i \cf5 //   ll_show(stack);
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7                         
\f2\b \cf6 return
\f1\b0 \cf7  \cf8 0\cf7 ;
\f0\fs24 \cf0 \

\f1\fs20 \cf7                     \}
\f0\fs24 \cf0 \

\f1\fs20 \cf7                     
\f3\i \cf5 //               puts("Subtracting");
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7                     op2 = ll_peek(stack);
\f0\fs24 \cf0 \

\f1\fs20 \cf7                     stack = ll_pop(stack);
\f0\fs24 \cf0 \

\f1\fs20 \cf7                     
\f3\i \cf5 //              ll_show(stack);
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7                     
\f3\i \cf5 //            printf("op2 = %d \\n", op2);
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7                     
\f0\fs24 \cf0 \

\f1\fs20 \cf7                     op1 = ll_peek(stack);
\f0\fs24 \cf0 \

\f1\fs20 \cf7                     
\f0\fs24 \cf0 \

\f1\fs20 \cf7                     stack = ll_pop(stack);
\f0\fs24 \cf0 \

\f1\fs20 \cf7                     
\f3\i \cf5 //                ll_show(stack);
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7                     
\f3\i \cf5 //               printf("op1 = %d \\n", op1);
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7                     
\f0\fs24 \cf0 \

\f1\fs20 \cf7                     result = op1 - op2;
\f0\fs24 \cf0 \

\f1\fs20 \cf7                     
\f0\fs24 \cf0 \

\f1\fs20 \cf7                     
\f3\i \cf5 //               printf("result = %d \\n", result);
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7                     
\f0\fs24 \cf0 \

\f1\fs20 \cf7                     stack = ll_push(result,stack);
\f0\fs24 \cf0 \

\f1\fs20 \cf7                     
\f3\i \cf5 //             puts("push result onto stack");
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7                     
\f3\i \cf5 //             ll_show(stack);
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7                     count-= \cf8 1\cf7 ;
\f0\fs24 \cf0 \

\f1\fs20 \cf7                 \}
\f0\fs24 \cf0 \

\f1\fs20 \cf7                 
\f3\i \cf5 //Multiplying
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7                 
\f2\b \cf6 else
\f1\b0 \cf7  
\f2\b \cf6 if
\f1\b0 \cf7 (strcmp(s,\cf4 "*"\cf7 ) == \cf8 0\cf7  || strcmp(s,\cf4 "*\\n"\cf7 )  == \cf8 0\cf7  || strcmp(s,\cf4 "* "\cf7 ) == \cf8 0\cf7  || strcmp(s,\cf4 "* \\n"\cf7 ) == \cf8 0\cf7 )
\f0\fs24 \cf0 \

\f1\fs20 \cf7                 \{
\f0\fs24 \cf0 \

\f1\fs20 \cf7                     
\f2\b \cf6 if
\f1\b0 \cf7 (count < \cf8 2\cf7 )
\f0\fs24 \cf0 \

\f1\fs20 \cf7                     \{
\f0\fs24 \cf0 \

\f1\fs20 \cf7                         
\f3\i \cf5 //        ll_show(stack);
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7                         
\f2\b \cf6 return
\f1\b0 \cf7  \cf8 0\cf7 ;
\f0\fs24 \cf0 \

\f1\fs20 \cf7                     \}
\f0\fs24 \cf0 \

\f1\fs20 \cf7                     
\f3\i \cf5 //               puts("Mult.");
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7                     op2 = ll_peek(stack);
\f0\fs24 \cf0 \

\f1\fs20 \cf7                     stack = ll_pop(stack);
\f0\fs24 \cf0 \

\f1\fs20 \cf7                     
\f3\i \cf5 //             ll_show(stack);
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7                     
\f3\i \cf5 //           printf("op2 = %d \\n", op2);
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7                     
\f0\fs24 \cf0 \

\f1\fs20 \cf7                     op1 = ll_peek(stack);
\f0\fs24 \cf0 \

\f1\fs20 \cf7                     
\f0\fs24 \cf0 \

\f1\fs20 \cf7                     stack = ll_pop(stack);
\f0\fs24 \cf0 \

\f1\fs20 \cf7                     
\f3\i \cf5 //       ll_show(stack);
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7                     
\f3\i \cf5 //         printf("op1 = %d \\n", op1);
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7                     
\f0\fs24 \cf0 \

\f1\fs20 \cf7                     result = op1 * op2;
\f0\fs24 \cf0 \

\f1\fs20 \cf7                     
\f0\fs24 \cf0 \

\f1\fs20 \cf7                     
\f3\i \cf5 //     printf("result = %d \\n", result);
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7                     
\f0\fs24 \cf0 \

\f1\fs20 \cf7                     stack = ll_push(result,stack);
\f0\fs24 \cf0 \

\f1\fs20 \cf7                     
\f3\i \cf5 // puts("push result onto stack");
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7                     
\f3\i \cf5 //  ll_show(stack);
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7                     count-= \cf8 1\cf7 ;
\f0\fs24 \cf0 \

\f1\fs20 \cf7                 \}
\f0\fs24 \cf0 \

\f1\fs20 \cf7                 
\f3\i \cf5 //Dividing
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7                 
\f2\b \cf6 else
\f1\b0 \cf7  
\f2\b \cf6 if
\f1\b0 \cf7 (strcmp(s,\cf4 "/"\cf7 ) == \cf8 0\cf7  || strcmp(s,\cf4 "/\\n"\cf7 )  == \cf8 0\cf7  || strcmp(s,\cf4 "/ "\cf7 ) == \cf8 0\cf7  || strcmp(s,\cf4 "/ \\n"\cf7 ) == \cf8 0\cf7 )
\f0\fs24 \cf0 \

\f1\fs20 \cf7                 \{
\f0\fs24 \cf0 \

\f1\fs20 \cf7                     
\f2\b \cf6 if
\f1\b0 \cf7 (count < \cf8 2\cf7 )
\f0\fs24 \cf0 \

\f1\fs20 \cf7                     \{
\f0\fs24 \cf0 \

\f1\fs20 \cf7                         
\f3\i \cf5 //         ll_show(stack);
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7                         
\f2\b \cf6 return
\f1\b0 \cf7  \cf8 0\cf7 ;
\f0\fs24 \cf0 \

\f1\fs20 \cf7                     \}
\f0\fs24 \cf0 \

\f1\fs20 \cf7                     
\f3\i \cf5 //                puts("Dividing");
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7                     op2 = ll_peek(stack);
\f0\fs24 \cf0 \

\f1\fs20 \cf7                     stack = ll_pop(stack);
\f0\fs24 \cf0 \

\f1\fs20 \cf7                     
\f3\i \cf5 //              ll_show(stack);
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7                     
\f3\i \cf5 //            printf("op2 = %d \\n", op2);
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7                     
\f0\fs24 \cf0 \

\f1\fs20 \cf7                     op1 = ll_peek(stack);
\f0\fs24 \cf0 \

\f1\fs20 \cf7                     
\f0\fs24 \cf0 \

\f1\fs20 \cf7                     stack = ll_pop(stack);
\f0\fs24 \cf0 \

\f1\fs20 \cf7                     
\f3\i \cf5 //          ll_show(stack);
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7                     
\f3\i \cf5 //        printf("op1 = %d \\n", op1);
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7                     
\f0\fs24 \cf0 \

\f1\fs20 \cf7                     result = op1 / op2;
\f0\fs24 \cf0 \

\f1\fs20 \cf7                     
\f0\fs24 \cf0 \

\f1\fs20 \cf7                     
\f3\i \cf5 //       printf("result = %d \\n", result);
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7                     
\f0\fs24 \cf0 \

\f1\fs20 \cf7                     stack = ll_push(result,stack);
\f0\fs24 \cf0 \

\f1\fs20 \cf7                     
\f3\i \cf5 //     puts("push result onto stack");
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7                      
\f3\i \cf5 //  ll_show(stack);
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7                     count-= \cf8 1\cf7 ;
\f0\fs24 \cf0 \

\f1\fs20 \cf7                 \}
\f0\fs24 \cf0 \

\f1\fs20 \cf7                 
\f2\b \cf6 else
\f1\b0 \cf7 \{
\f0\fs24 \cf0 \

\f1\fs20 \cf7                      ll_show(stack);
\f0\fs24 \cf0 \

\f1\fs20 \cf7                      
\f0\fs24 \cf0 \

\f1\fs20 \cf7                     
\f2\b \cf6 return
\f1\b0 \cf7  \cf8 0\cf7 ;
\f0\fs24 \cf0 \

\f1\fs20 \cf7                     
\f0\fs24 \cf0 \

\f1\fs20 \cf7                     
\f0\fs24 \cf0 \

\f1\fs20 \cf7                 \}
\f0\fs24 \cf0 \

\f1\fs20 \cf7                 
\f0\fs24 \cf0 \

\f1\fs20 \cf7             \}
\f3\i \cf5 //ends big if statement
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7             memset(buff,\cf8 0\cf7 ,strlen(buff));
\f0\fs24 \cf0 \

\f1\fs20 \cf7         \}
\f0\fs24 \cf0 \

\f1\fs20 \cf7              
\f3\i \cf5 //   ll_show(stack);
\f0\i0\fs24 \cf0 \

\f1\fs20 \cf7     \}
\f0\fs24 \cf0 \

\f1\fs20 \cf7     
\f0\fs24 \cf0 \

\f1\fs20 \cf7     
\f0\fs24 \cf0 \

\f1\fs20 \cf7     
\f2\b \cf6 return
\f1\b0 \cf7  \cf8 0\cf7 ;
\f0\fs24 \cf0 \

\f1\fs20 \cf7 \}
\f0\fs24 \cf0 \
}